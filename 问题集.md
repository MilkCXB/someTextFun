防抖 节流原理
见someFun
都是用以防止函数的快速重复多次的调用。
区别：假如一直触发函数 防抖在设置的时间内只会触发一次   而节流会根据设置的时间不断调用函数。
防抖原理：通过定时器去触发方法，如果重复多次调用，则清除当前定时器，开始一个新的定时器，直到定时器自动触发当前方法。
节流原理：类似于游戏里的技能冷却，就是当它触发了一次之后会失效一段时间，等待时间后才能使用。

自定义指令
通过vue.directive(name,()=>{}) 去使用 回调函数里有对应的事件方法。

后台管理系统权限设置
通过vuex去存储后端返回来的权限列表，通过addRoute动态路由去渲染当前身份符合的路由。

登录权限
使用生成token的方法，在请求总设置的地方进行处理，比如我项目用的axios的话，就是用请求拦截器，在请求前把token带上，
如果没有token则提示无法请求。生成token的方法我一般也会放vuex。

vue2和vue3的区别
1.双向绑定的不同。vue2使用的是ObjectdefineProperty去进行数据劫持对属性的双向绑定，而vue3使用的是Proxy数据代理。
2.vue2使用optionsAPI，而vue3是用composition API,主要特征有：(1).setup (2).ref,reactive定义响应式数据 (3).取消部分
生命周期函数。(4).取消filter建议使用computed。


object.defineProperty和proxy区别
区别在于 defineProperty 需要通过遍历递归去把每一个属性的值进行defineProperty数据劫持，把每一个属性变成响应式数据，
而且无法去监听新增的或者删除的对象，而proxy是监听整一个对象的，但是假如对象里还有个对象，那么还需要进行深度监听，即遍历
同时数组监听的话，vue2是通过重写array的方法去实现监听的，即在原来的基础上多个拦截器。

defineProperty原理
如上。

proxy原理 
如上。（Reflect对象的get set 方法）

proxy添加一个不存在对象
通过Rflect添加方法 也可以使其添加的对象产生响应式。

vite热重载原理


js运行环境
node环境  浏览器环境

node单双线程？单线程。有类似event loop的处理。本身只需要遵循单线程。

原型原型链?
原型是本身函数具有的，叫做prototype，它会有这个函数本身的属性和方法，原型链是实例指向生成实例的函数或者类的，叫做__proto__。原型继承的原理是，当前prototype如果没找到属性或者方法，则会跟着原型链往上找，如果有则输出，无则继续往上，一直到Object.prototype结束。


promise 原理
分为三个状态，pending(等待),fulfilled(完成),rejected(失败)，两个回调 resolve reject。特性是，当状态一旦发生改变就不可逆，promise通过resolve处理成功事件，修改状态以及传入数据，reject处理错误失败事件，抛出错误。同时还需要处理异步的时候，通过定义数组resolves存储函数，等到then时如果还是pending状态，则把他存入回调函数，等开始处理时再把回调函数一一拿出执行。
then包含链式调用 处理不同状态的数据 返回一个promise对象。

泛型定义？

当new的时候发生了什么
1 新建对象作为实例 2 把构造函数的prototype赋给新对象的__proto__ 3 修改构造函数的this指向实例  4.返回新实例

优化性能？
1.图片懒加载，图片雪碧图 2. 减少http请求，少用图片多用icon 3.通过webpack插件去打包文件，减少体积。4.代码方面，可以把css放前面，js放后面，因为js渲染如果缓慢，则会导致堵塞，长时间处于一个白屏状态。5.骨架框，可以给用户更好的体验。6.强缓存和缓存

响应式布局方式？
flex布局。rem布局。窗口布局。

为什么js是单线程的？
如果是多线程，假如同时修改一个dom，会造成混乱，dom不知道该听哪个线程。

js为什么需要异步执行模式？event loop。 防止同步事件阻塞。

event loop的具体执行机制？
判断事件是同步还是异步，如果是同步则放入主线程，如果是异步放入eventtable，验证可执行后放入eventqueue，当主线程的同步任务执行完毕后，开始把event队列里的异步事件放入主线程执行，执行完毕后再进行一轮循环。 

vite为什么比webpack快？

computed跟watch有什么区别？
computed的话主要用于监听多个数据影响一个数据，而watch是用于监听一个数据影响多个数据，同时watch也能监听异步。

你常用的设计模式有哪些？工厂模式，发布订阅模式，适配器模式，外观模式

proxy是否可以深度监听到对象里的对象？
没法。得用遍历继续深一层的监听。

简单说说闭包？场景？
简单来说就是 函数里面返回一个函数 可以让外面访问到里面的数据，由函数和词法作用域形成的，叫做闭包。场景的话，第一个可以作为内部数据的过滤器，不会受外界影响。第二个是可以作为面向对象编程，同时拥有私有方法和共有方法这个模式。缺点是回收机制无法把这种函数给回收了，会造成性能上的影响。

箭头函数与普通函数的区别？
1.普通函数的话 它的this指向调用它的对象的作用域，箭头函数则直接指向最外层的作用域。
2.箭头函数无法使用new，而普通函数可以，this指向的问题。
3.箭头函数有类似的简写，比如说()=>某个值，没有大括号，则它会自动return这个值。
4.

computed 原理？

url从输入网址做了什么？
从输入url开始 先会进行缓存的判断，判断是否有强缓存或者协商缓存，再决定需不需要请求服务器，之后再对http进行dns解析，解析完之后开始进行http请求，tcp连接，进行三次握手，服务器收到消息后会返回静态的页面给前端，前端开始渲染dom树，css树，js树，最后渲染完成。当要结束一段连接的时候，需要进行四次挥手，完成连接。

三次握手：1.客户端通知服务器 我要开始请求了  2.服务器说没问题，可以开始请求，返回响应给客户端。3.客户端正式发送请求给服务器。

四次挥手：

小程序父组件如何修改子组件样式？externalClasses

http请求包括有什么？请求头 请求行 请求数据 空行

get post 有何区别？
get 在url传递参数 安全性方面 弱  存储数据方面，url长度有限，无法传太多参数
post  在body传递参数 安全性方面 强 post可以传更多参数

vite特性：更快的冷启动速度，更快HMR速度，真正的按需编译。
vite本身依赖于module sciprt的特性，利用websocket传输文件变化，本地保存完文件后，就能实时在浏览器中预览到效果，非常好用。
vite重点：1.因为越来越多浏览器支持ESM，不用打包编译，kao服务直接开启开发服务器。2.HMR很快。只更新修改的模块，不会随包的变大而变大
vite热重载HMR原理：监听文件变化（node的watchfile API）  css热替换 js热替换reload  
vite为什么比webpack快？1.weback需要先进行本地打包，生成bundles文件，再开启开发服务器。而vite利用浏览器ESM特性，只需要直接开启
开发服务器，对相应模块按需编译即可。2.HMR基于websocket建立浏览器与服务器的连接webpack的HMR对改变的模块所依赖的模块也会一起
发生改变，进行编译。vite的HMR则可以通过ESM特性对修改的模块实现即时替换


